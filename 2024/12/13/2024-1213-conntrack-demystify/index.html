<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Conntrack 作为实现 NAT 的基础模块，在内核中经常见到，而且它开销挺大。这里我们做一些关于它实现的笔记。 Kernel version: v6.8 1. purposeConntrack，也就是连接跟踪，通过它可以监控和管理网络连接的状态。 我们可以用 conntrack 命令来查看 conntrack 子系统的一些细节： 12345678~ sudo conntrack -L -p">
<meta property="og:type" content="article">
<meta property="og:title" content="conntrack demystify">
<meta property="og:url" content="https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/index.html">
<meta property="og:site_name" content="Kangjie&#39;s Homepage">
<meta property="og:description" content="Conntrack 作为实现 NAT 的基础模块，在内核中经常见到，而且它开销挺大。这里我们做一些关于它实现的笔记。 Kernel version: v6.8 1. purposeConntrack，也就是连接跟踪，通过它可以监控和管理网络连接的状态。 我们可以用 conntrack 命令来查看 conntrack 子系统的一些细节： 12345678~ sudo conntrack -L -p">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://middaywords.github.io/figures/image-20250225180849094.png">
<meta property="og:image" content="https://middaywords.github.io/figures/image-20250225182830273.png">
<meta property="og:image" content="https://middaywords.github.io/figures/image-20250301151146788.png">
<meta property="article:published_time" content="2024-12-13T14:16:09.000Z">
<meta property="article:modified_time" content="2025-03-01T09:28:23.655Z">
<meta property="article:author" content="Kangjie Xu">
<meta property="article:tag" content="network">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://middaywords.github.io/figures/image-20250225180849094.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>conntrack demystify</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/12/13/2024-1213-networking-timestamp/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/12/13/2024-1213-kprobe-demystify/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&text=conntrack demystify"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&is_video=false&description=conntrack demystify"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=conntrack demystify&body=Check out this article: https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&name=conntrack demystify&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&t=conntrack demystify"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-purpose"><span class="toc-number">1.</span> <span class="toc-text">1. purpose</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Overview"><span class="toc-number">2.</span> <span class="toc-text">2. Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Conntrack-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">3. Conntrack 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 相关数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 大致流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-ct-connection-lifecycle"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 ct connection lifecycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-nf-conntrack-in%EF%BC%9A%E8%BF%9B%E5%85%A5%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 nf_conntrack_in：进入连接跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-resolve-normal-ct-%E5%A4%84%E7%90%86%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 resolve_normal_ct: 处理新连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-nf-conntrack-confirm%EF%BC%9A%E7%A1%AE%E8%AE%A4%E5%8C%85%E5%8A%A0%E5%85%A5-conntrack-table"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 nf_conntrack_confirm：确认包加入 conntrack table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-connection-%E7%9A%84timeout%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8Cgc"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 connection 的timeout，删除，gc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-nf-conn-%E9%87%8A%E6%94%BE"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 nf_conn 释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-conntrack-timeout"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 conntrack timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-conntrack-gc"><span class="toc-number">3.7.3.</span> <span class="toc-text">3.7.3 conntrack gc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-questions"><span class="toc-number">4.</span> <span class="toc-text">4. questions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">5.</span> <span class="toc-text">reference</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        conntrack demystify
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Kangjie Xu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-13T14:16:09.000Z" class="dt-published" itemprop="datePublished">2024-12-13</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/linux/" rel="tag">linux</a>, <a class="p-category" href="/tags/network/" rel="tag">network</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>Conntrack 作为实现 NAT 的基础模块，在内核中经常见到，而且它开销挺大。这里我们做一些关于它实现的笔记。</p>
<p>Kernel version: v6.8</p>
<h1 id="1-purpose"><a href="#1-purpose" class="headerlink" title="1. purpose"></a>1. purpose</h1><p>Conntrack，也就是连接跟踪，通过它可以监控和管理网络连接的状态。</p>
<p>我们可以用 <code>conntrack</code> 命令来查看 conntrack 子系统的一些细节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ sudo conntrack -L -p tcp</span><br><span class="line">tcp      6 4 TIME_WAIT src=10.147.1.7 dst=10.196.118.30 sport=41662 dport=4506 src=10.196.118.30 dst=10.147.1.7 sport=4506 dport=41662 [ASSURED] mark=0 use=1</span><br><span class="line">tcp      6 26 TIME_WAIT src=10.147.1.7 dst=10.196.118.30 sport=41930 dport=4506 src=10.196.118.30 dst=10.147.1.7 sport=4506 dport=41930 [ASSURED] mark=0 use=1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">~ sudo conntrack -L -p udp</span><br><span class="line">udp      17 2 src=10.147.1.7 dst=10.5.5.25 sport=47556 dport=53 src=10.5.5.25 dst=10.147.1.7 sport=53 dport=47556 mark=0 use=1</span><br><span class="line">udp      17 26 src=10.147.1.7 dst=10.5.5.25 sport=36338 dport=53 src=10.5.5.25 dst=10.147.1.7 sport=53 dport=36338 mark=0 use=1</span><br></pre></td></tr></table></figure>

<p>conntrack 子系统主要有两种作用</p>
<ol>
<li>维护包之间的<strong>关系</strong>。需要说明的是，这里我们说 connection，不仅仅指面向连接的协议 TCP 这种。比如 ICMP echo-request 和 ICMP echo-reply 的关系。</li>
<li>其他的内核组件，可以借助这些 connection 之间的关系信息，来做一些决策，包括： NAT，包过滤（比如防火墙 iptables&#x2F;nftables 可以借助这些信息做包过滤）</li>
</ol>
<h1 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h1><p>packet 在 network namespace 中的转发路径如图所示，conntrack 子系统也像 iptables&#x2F;nftables 一样，搭建于 netfilter 框架之上，它使用 netfilter 框架在一些 hook 点加入了一些处理逻辑，用于观察每个包的信息。</p>
<p><img src="/../figures/image-20250225180849094.png" alt="image-20250225180849094"></p>
<p>在图中，我们可以看到一些主要的 conntrack hook function（图中灰色部分）：</p>
<ol>
<li>Main ct hook：用于分析和关联包和跟踪的连接<ol>
<li>Ipv4_conntrack_in (-200)：挂在 prerouting chain 上，用于处理本地网络收到的包</li>
<li>ipv4_conntrack_local (-200)：挂在 output chain 上，用于处理从本地网络发出去的包</li>
</ol>
</li>
<li>Confirm hook function：用于确认新的跟踪的连接<ol>
<li>Ipv4_confirm (INT_MAX)：挂在 postrouting &amp; input chain。</li>
</ol>
</li>
<li>Defrag hook：重组 IP 分片<ol>
<li>Ipv4_conntrack_defrag(-400)：挂在 prerouting 和 output chain。</li>
</ol>
</li>
</ol>
<p>对于每个网络包，对于 ct 来说，有四种情形：</p>
<ol>
<li>它是已跟踪的连接之一，或者于已跟踪的连接相关</li>
<li>它属于新的连接，系统从没见过</li>
<li>它是个非法包，broken 或者和现有运行状态不兼容（不该出现）</li>
<li>被标记成了 NOTRACK，系统配置要求不追踪此类包。</li>
</ol>
<p>代码中相关定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* Connection tracking may drop packets, but never alters them, so</span><br><span class="line"> * make it the first hook.</span><br><span class="line"> */</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_conntrack_ops</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.hook		= ipv4_conntrack_in,</span><br><span class="line">		.pf		= NFPROTO_IPV4,</span><br><span class="line">		.hooknum	= NF_INET_PRE_ROUTING,</span><br><span class="line">		.priority	= NF_IP_PRI_CONNTRACK,      <span class="comment">//-200</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.hook		= ipv4_conntrack_local,</span><br><span class="line">		.pf		= NFPROTO_IPV4,</span><br><span class="line">		.hooknum	= NF_INET_LOCAL_OUT,</span><br><span class="line">		.priority	= NF_IP_PRI_CONNTRACK,      <span class="comment">//-200</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.hook		= ipv4_confirm,</span><br><span class="line">		.pf		= NFPROTO_IPV4,</span><br><span class="line">		.hooknum	= NF_INET_POST_ROUTING,</span><br><span class="line">		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,   <span class="comment">//INT_MAX</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.hook		= ipv4_confirm,</span><br><span class="line">		.pf		= NFPROTO_IPV4,</span><br><span class="line">		.hooknum	= NF_INET_LOCAL_IN,</span><br><span class="line">		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,   <span class="comment">//INT_MAX</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Defrag 相关 hook：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_defrag_ops</span>[] =</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.hook		= ipv4_conntrack_defrag,</span><br><span class="line">		.pf		= NFPROTO_IPV4,</span><br><span class="line">		.hooknum	= NF_INET_PRE_ROUTING,</span><br><span class="line">		.priority	= NF_IP_PRI_CONNTRACK_DEFRAG,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.hook           = ipv4_conntrack_defrag,</span><br><span class="line">		.pf             = NFPROTO_IPV4,</span><br><span class="line">		.hooknum        = NF_INET_LOCAL_OUT,</span><br><span class="line">		.priority       = NF_IP_PRI_CONNTRACK_DEFRAG,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-Conntrack-实现"><a href="#3-Conntrack-实现" class="headerlink" title="3. Conntrack 实现"></a>3. Conntrack 实现</h1><h2 id="3-1-相关数据结构"><a href="#3-1-相关数据结构" class="headerlink" title="3.1 相关数据结构"></a>3.1 相关数据结构</h2><ul>
<li><code>struct nf_conn</code> 对于每个连接，conntrack 使用结构体 <code>struct nf_conn</code> 来表示相关跟踪连接。</li>
<li><code>struct nf_conntrack_tuple</code> ：从包中提取的五元组信息</li>
<li><code>struct nf_conntrack_tuple_hash</code>：包的五元组哈希，作为 conntrack 表中的 entry。</li>
<li><code>nf_conntrack_hash</code>: 此外，会有一个 central ct table(struct hlist_nulls_head )，用于维护连接信息。</li>
</ul>
<p>skb 中，会有 tracked connection nf_conn 的引用，也就是 <code>skb-&gt;_nfct</code>。</p>
<h2 id="3-2-大致流程"><a href="#3-2-大致流程" class="headerlink" title="3.2 大致流程"></a>3.2 大致流程</h2><p><img src="/../figures/image-20250225182830273.png" alt="image-20250225182830273"></p>
<p>在 prerouting hook 的 conntrack_in 中，对包进行处理，首先会去 central ct table 里面查找包是否与某个连接信息相关，有的话就设置，否则放到 unconfirmed list 里面。在处理到 input hook 的 confirm hook 的时候。</p>
<p>上面是 5.x 的情况，对于 kernel 6.x，代码有些不同 uncofirmed list 被移除了，分配直接通过 slab 分配器 <code>kmem_cache (nf_conntrack_cachep)</code> 来管理。当相关 nf_conn 被调用到 <code>nf_ct_put()</code> 的时候，若引用计数为0，会将其在 kmem cache 里面的分配内存释放，并清理相关数据。</p>
<h2 id="3-3-ct-connection-lifecycle"><a href="#3-3-ct-connection-lifecycle" class="headerlink" title="3.3 ct connection lifecycle"></a>3.3 ct connection lifecycle</h2><p><img src="/../figures/image-20250301151146788.png" alt="image-20250301151146788"></p>
<p>通常来说，一个新连接首先被加入到 unconfirmed list，然后再被 confirm 之后，被加入到 central ct table。之后它会一直待在 central ct table 里面直到 connection 过期 timeout，连接一直没有包的话，就会过期。一旦过期，就会放到 dying list，被删除。</p>
<h2 id="3-4-nf-conntrack-in：进入连接跟踪"><a href="#3-4-nf-conntrack-in：进入连接跟踪" class="headerlink" title="3.4 nf_conntrack_in：进入连接跟踪"></a>3.4 nf_conntrack_in：进入连接跟踪</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nf_conntrack_in</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ip_conntrack_info</span> <span class="title">ctinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>, *<span class="title">tmpl</span>;</span></span><br><span class="line">    <span class="type">u_int8_t</span> protonum;</span><br><span class="line">    <span class="type">int</span> dataoff, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据包的连接跟踪信息</span></span><br><span class="line">    tmpl = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (tmpl || ctinfo == IP_CT_UNTRACKED) &#123;</span><br><span class="line">        <span class="comment">// 如果数据包是模板连接或未跟踪连接，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span> ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED)</span><br><span class="line">            <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        skb-&gt;_nfct = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取传输层协议的偏移量</span></span><br><span class="line">    dataoff = get_l4proto(skb, skb_network_offset(skb), state-&gt;pf, &amp;protonum);</span><br><span class="line">    <span class="keyword">if</span> (dataoff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取失败，则增加无效计数器并放行数据包</span></span><br><span class="line">        NF_CT_STAT_INC_ATOMIC(state-&gt;net, invalid);</span><br><span class="line">        ret = NF_ACCEPT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 ICMP 和 ICMPv6 协议的数据包</span></span><br><span class="line">    <span class="keyword">if</span> (protonum == IPPROTO_ICMP || protonum == IPPROTO_ICMPV6) &#123;</span><br><span class="line">        ret = nf_conntrack_handle_icmp(tmpl, skb, dataoff, protonum, state);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ret = -ret;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 ICMP 处理器分配了连接跟踪，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;_nfct)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">// 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态</span></span><br><span class="line">    ret = resolve_normal_ct(tmpl, skb, dataoff, protonum, state);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果处理失败，则增加丢弃计数器并丢弃数据包</span></span><br><span class="line">        NF_CT_STAT_INC_ATOMIC(state-&gt;net, drop);</span><br><span class="line">        ret = NF_DROP;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据包的连接跟踪信息</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (!ct) &#123;</span><br><span class="line">        <span class="comment">// 如果数据包不属于有效连接，则增加无效计数器并放行数据包</span></span><br><span class="line">        NF_CT_STAT_INC_ATOMIC(state-&gt;net, invalid);</span><br><span class="line">        ret = NF_ACCEPT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据包并更新连接跟踪状态</span></span><br><span class="line">    ret = nf_conntrack_handle_packet(ct, skb, dataoff, ctinfo, state);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果处理失败，则释放连接跟踪并重置数据包的连接跟踪信息</span></span><br><span class="line">        nf_ct_put(ct);</span><br><span class="line">        skb-&gt;_nfct = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 特殊情况：TCP 连接尝试重新打开已关闭的连接，需要重新创建连接跟踪</span></span><br><span class="line">        <span class="keyword">if</span> (ret == -NF_REPEAT)</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line"></span><br><span class="line">        NF_CT_STAT_INC_ATOMIC(state-&gt;net, invalid);</span><br><span class="line">        <span class="keyword">if</span> (ret == -NF_DROP)</span><br><span class="line">            NF_CT_STAT_INC_ATOMIC(state-&gt;net, drop);</span><br><span class="line"></span><br><span class="line">        ret = -ret;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是已建立的回复连接，并且这是第一次看到回复，则触发连接事件缓存更新</span></span><br><span class="line">    <span class="keyword">if</span> (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp;</span><br><span class="line">        !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))</span><br><span class="line">        nf_conntrack_event_cache(IPCT_REPLY, ct);</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 释放模板连接</span></span><br><span class="line">    <span class="keyword">if</span> (tmpl)</span><br><span class="line">        nf_ct_put(tmpl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nf_conntrack_in);</span><br></pre></td></tr></table></figure>

<p>这个函数通过识别并更新数据包对应的连接跟踪信息来决定数据包的命运。大致流程如下：</p>
<ul>
<li>首先检查数据包是否已被标记为模板连接或不跟踪的连接，如果是则直接放行。</li>
<li>然后解析传输层协议(ICMP、TCP等)，并在需要时调用专门的处理逻辑(如处理ICMP报文)。</li>
<li>若发现连接跟踪需要更新，就分配或获取对应的连接跟踪结构(nf_conn)，并根据数据包的方向和状态决定是否放行、丢弃或重新建立连接跟踪。</li>
<li>最后对已完成握手的连接进行回包标记，触发连接事件缓存更新。</li>
</ul>
<h2 id="3-5-resolve-normal-ct-处理新连接"><a href="#3-5-resolve-normal-ct-处理新连接" class="headerlink" title="3.5 resolve_normal_ct: 处理新连接"></a>3.5 resolve_normal_ct: 处理新连接</h2><p>上文 <code>conntrack_in</code> 中核心函数是 <code>resolve_normal_ct</code>，它处理包时，发现它属于一个新的连接，需要进行处理，我们下面简单解析一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* On success, returns 0, sets skb-&gt;_nfct | ctinfo */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">resolve_normal_ct</span><span class="params">(<span class="keyword">struct</span> nf_conn *tmpl,</span></span><br><span class="line"><span class="params">		  <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> dataoff,</span></span><br><span class="line"><span class="params">		  <span class="type">u_int8_t</span> protonum,</span></span><br><span class="line"><span class="params">		  <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 1. 解析得到 nf_conntrack_tuple</span></span><br><span class="line">	<span class="keyword">if</span> (!nf_ct_get_tuple(skb, skb_network_offset(skb),</span><br><span class="line">			     dataoff, state-&gt;pf, protonum, state-&gt;net,</span><br><span class="line">			     &amp;tuple))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 在 central ct table，也就是 nf_conntrack_hash 中寻找 tuple 信息</span></span><br><span class="line">	<span class="comment">/* look for tuple match */</span></span><br><span class="line">	zone = nf_ct_zone_tmpl(tmpl, skb, &amp;tmp);</span><br><span class="line">	zone_id = nf_ct_zone_id(zone, IP_CT_DIR_ORIGINAL);</span><br><span class="line">	hash = hash_conntrack_raw(&amp;tuple, zone_id, state-&gt;net);</span><br><span class="line">	h = __nf_conntrack_find_get(state-&gt;net, zone, &amp;tuple, hash);</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!h) &#123;</span><br><span class="line">		h = init_conntrack(state-&gt;net, tmpl, &amp;tuple,</span><br><span class="line">				   skb, dataoff, hash);</span><br><span class="line">		<span class="keyword">if</span> (!h)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(h))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(h);</span><br><span class="line">	&#125;</span><br><span class="line">	ct = nf_ct_tuplehash_to_ctrack(h);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* It exists; we have (non-exclusive) reference. */</span></span><br><span class="line">	<span class="keyword">if</span> (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY) &#123;</span><br><span class="line">		ctinfo = IP_CT_ESTABLISHED_REPLY;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> status = READ_ONCE(ct-&gt;status);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Once we&#x27;ve had two way comms, always ESTABLISHED. */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(status &amp; IPS_SEEN_REPLY))</span><br><span class="line">			ctinfo = IP_CT_ESTABLISHED;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (status &amp; IPS_EXPECTED)</span><br><span class="line">			ctinfo = IP_CT_RELATED;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ctinfo = IP_CT_NEW;</span><br><span class="line">	&#125;</span><br><span class="line">	nf_ct_set(skb, ct, ctinfo);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>nf_ct_get_tuple</code>：解析 skb 得到 struct nf_conn 和 nf_conntrack_tuple</li>
<li><code>nf_ct_zone_tmpl</code>&#x2F;<code>nf_ct_zone_id</code>：根据 tmpl 找到相关的 conntrack zone<ul>
<li>关于 conntrack zone：使用 skb-&gt;mark 用于区分 device，可以参考 <a target="_blank" rel="noopener" href="https://arthurchiao.art/blog/packet-mark-in-a-cloud-native-world-zh/">[译] 云原生世界中的数据包标记（packet mark）(LPC, 2020)</a> 和 <a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/42614127">Linux Netfilter conntrack对zone的支持</a> 总之把 conntrack 表分的小一些了</li>
</ul>
</li>
<li><code>__nf_conntrack_find_get</code> 到 central ct table 中查找 tuple 是否存在</li>
<li>如果 central ct table 中不存在，则调用 <code>init_conntrack</code> 新建连接，这里是使用 <code>kmem_cache_alloc</code> 进行分配的，不涉及 central ct table 的修改。</li>
</ul>
<p>简单说，该函数会根据数据包与模板信息确定连接跟踪结构（<code>struct nf_conn</code>）。它先提取五元组（tuple），然后在散列表中查找对应的连接。如果没找到，则调用 <code>init_conntrack()</code> 新建连接。随后根据连接方向和状态标志（如 <code>IPS_SEEN_REPLY</code>）设置 <code>ctinfo</code>。最后通过 <code>nf_ct_set(skb, ct, ctinfo)</code> 将连接信息与当前数据包关联。这样便能跟踪该数据包属于哪条连接以及其连接状态。</p>
<h2 id="3-6-nf-conntrack-confirm：确认包加入-conntrack-table"><a href="#3-6-nf-conntrack-confirm：确认包加入-conntrack-table" class="headerlink" title="3.6 nf_conntrack_confirm：确认包加入 conntrack table"></a>3.6 nf_conntrack_confirm：确认包加入 conntrack table</h2><p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 由 kmem cache <code>nf_conntrack_cachep</code> 分配。</p>
<p><code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p>
<p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Confirm a connection given skb; places it in hash table */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__nf_conntrack_confirm(<span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">    local_bh_disable();               <span class="comment">// 关闭软中断</span></span><br><span class="line"></span><br><span class="line">    hash = *(<span class="type">unsigned</span> <span class="type">long</span> *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;</span><br><span class="line">    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line"></span><br><span class="line">    ct-&gt;timeout += nfct_time_stamp;   <span class="comment">// 更新连接超时时间，超时后会被 GC</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;ct-&gt;ct_general.use);  <span class="comment">// 设置连接引用计数？</span></span><br><span class="line">    ct-&gt;status |= IPS_CONFIRMED;      <span class="comment">// 设置连接状态为 confirmed</span></span><br><span class="line"></span><br><span class="line">    __nf_conntrack_hash_insert(ct, hash, reply_hash);  <span class="comment">// 插入到连接跟踪哈希表</span></span><br><span class="line"></span><br><span class="line">    local_bh_enable();                <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7-connection-的timeout，删除，gc"><a href="#3-7-connection-的timeout，删除，gc" class="headerlink" title="3.7 connection 的timeout，删除，gc"></a>3.7 connection 的timeout，删除，gc</h2><h3 id="3-7-1-nf-conn-释放"><a href="#3-7-1-nf-conn-释放" class="headerlink" title="3.7.1 nf_conn 释放"></a>3.7.1 nf_conn 释放</h3><p>当 <code>nf_conntrack_put()</code> 把 reference count 计数器减少到 0，就会调用 <code>nf_conntrack_destroy</code> 把 nf_conn 结构释放掉，这有两种情况，</p>
<ol>
<li>packet 在未加入 central ct table(即未被 confirm) 的过程中，需要被丢弃。在其中会调用 <code>nf_conntrack_put</code>，将需要 drop 的包相关 nf_conn 释放掉。还有种情况是 <code>skb_release_head_state</code>（好像和 segment 有关）。</li>
<li>当 connection 在 dying list 里面，会将过期的 connection 的 nf_conn 释放掉。</li>
</ol>
<h3 id="3-7-2-conntrack-timeout"><a href="#3-7-2-conntrack-timeout" class="headerlink" title="3.7.2 conntrack timeout"></a>3.7.2 conntrack timeout</h3><p>在 conntrack_confirm 的时候，会为 nf_conn 设置 timeout</p>
<p>在 conntrack_in 的时候，调用到 <code>nf_conntrack_handle_packet</code>，解析处理各种协议 conntrack 信息，其中会调用到 <code>__nf_ct_refresh_acct</code>，这其中会更新相关 nf_conn 的 timeout 值。nf_conn 对应连接一直没有包的话，那么就一直不会更新 timeout 值，最后被 gc 了</p>
<h3 id="3-7-3-conntrack-gc"><a href="#3-7-3-conntrack-gc" class="headerlink" title="3.7.3 conntrack gc"></a>3.7.3 conntrack gc</h3><p>conntrack 的 gc 是通过 workqueue 来实现的，他会周期 queue_work 来执行 gc 工作</p>
<p>它会以哈希桶为单位扫描连接跟踪表，删除已过期或符合“早期丢弃”条件的连接条目，并计算下一次扫描的延迟。主要步骤如下：</p>
<ol>
<li>根据当前哈希表大小与扫描索引 (i)，逐个获取连接条目。</li>
<li>如果超出设置的最大处理数或已消耗过多时间，就记录进度并提前退出，防止长时间阻塞。</li>
<li>使用 nf_ct_is_expired(…) 检测条目是否过期；若过期则直接清理。</li>
<li>动态计算下次超时时间 next_run，用于控制扫描频率。</li>
<li>当连接总数超过一定阈值时 (nf_conntrack_max95)，会触发 early_drop 逻辑，强制清理部分连接。</li>
<li>处理完后，更新扫描索引，重新排队延迟工作 (queue_delayed_work)，以在适当的时候继续后续扫描。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gc_worker</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, hashsz, nf_conntrack_max95 = <span class="number">0</span>;</span><br><span class="line">    u32 end_time, start_time = nfct_time_stamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conntrack_gc_work</span> *<span class="title">gc_work</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> expired_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> next_run;</span><br><span class="line">    s32 delta_time;</span><br><span class="line">    <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 workqueue</span></span><br><span class="line">    gc_work = container_of(work, <span class="keyword">struct</span> conntrack_gc_work, dwork.work);</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    end_time = start_time + GC_SCAN_MAX_DURATION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *<span class="title">h</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> *<span class="title">ct_hash</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">n</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取哈希表和大小</span></span><br><span class="line">        nf_conntrack_get_ht(&amp;ct_hash, &amp;hashsz);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= hashsz) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历哈希桶中的所有连接</span></span><br><span class="line">        hlist_nulls_for_each_entry_rcu(h, n, &amp;ct_hash[i], hnnode) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_net</span> *<span class="title">cnet</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">            <span class="type">long</span> expires;</span><br><span class="line"></span><br><span class="line">            tmp = nf_ct_tuplehash_to_ctrack(h);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理 offload 连接</span></span><br><span class="line">            <span class="keyword">if</span> (test_bit(IPS_OFFLOAD_BIT, &amp;tmp-&gt;status)) &#123;</span><br><span class="line">                nf_ct_offload_timeout(tmp);</span><br><span class="line">                <span class="keyword">if</span> (!nf_conntrack_max95)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果过期连接数超过最大值，提前退出</span></span><br><span class="line">            <span class="keyword">if</span> (expired_count &gt; GC_SCAN_EXPIRED_MAX) &#123;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">                gc_work-&gt;next_bucket = i;</span><br><span class="line">                gc_work-&gt;avg_timeout = next_run;</span><br><span class="line">                gc_work-&gt;count = count;</span><br><span class="line"></span><br><span class="line">                delta_time = nfct_time_stamp - gc_work-&gt;start_time;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果总循环时间超过最大值，立即重新调度</span></span><br><span class="line">                next_run = delta_time &lt; (s32)GC_SCAN_INTERVAL_MAX;</span><br><span class="line">                <span class="keyword">goto</span> early_exit;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果连接已过期，删除连接</span></span><br><span class="line">            <span class="keyword">if</span> (nf_ct_is_expired(tmp)) &#123;</span><br><span class="line">                nf_ct_gc_expired(tmp);</span><br><span class="line">                expired_count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下次运行时间</span></span><br><span class="line">            expires = clamp(nf_ct_expires(tmp), GC_SCAN_INTERVAL_MIN, GC_SCAN_INTERVAL_CLAMP);</span><br><span class="line">            expires = (expires - (<span class="type">long</span>)next_run) / ++count;</span><br><span class="line">            next_run += expires;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不需要 early drop 或者跳过当前连接，继续下一个</span></span><br><span class="line">            <span class="keyword">if</span> (nf_conntrack_max95 == <span class="number">0</span> || gc_worker_skip_ct(tmp))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            net = nf_ct_net(tmp);</span><br><span class="line">            cnet = nf_ct_pernet(net);</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;cnet-&gt;count) &lt; nf_conntrack_max95)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加引用计数，避免竞争条件</span></span><br><span class="line">            <span class="keyword">if</span> (!refcount_inc_not_zero(&amp;tmp-&gt;ct_general.use))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在引用计数增加后加载状态</span></span><br><span class="line">            smp_acquire__after_ctrl_dep();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要跳过当前连接，继续下一个</span></span><br><span class="line">            <span class="keyword">if</span> (gc_worker_skip_ct(tmp)) &#123;</span><br><span class="line">                nf_ct_put(tmp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果可以 early drop，删除连接</span></span><br><span class="line">            <span class="keyword">if</span> (gc_worker_can_early_drop(tmp)) &#123;</span><br><span class="line">                nf_ct_kill(tmp);</span><br><span class="line">                expired_count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nf_ct_put(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        cond_resched();</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果时间超过最大值，提前退出</span></span><br><span class="line">        delta_time = nfct_time_stamp - end_time;</span><br><span class="line">        <span class="keyword">if</span> (delta_time &gt; <span class="number">0</span> &amp;&amp; i &lt; hashsz) &#123;</span><br><span class="line">            gc_work-&gt;avg_timeout = next_run;</span><br><span class="line">            gc_work-&gt;count = count;</span><br><span class="line">            gc_work-&gt;next_bucket = i;</span><br><span class="line">            next_run = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> early_exit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; hashsz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置哈希桶索引</span></span><br><span class="line">    gc_work-&gt;next_bucket = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制下次运行时间</span></span><br><span class="line">    next_run = clamp(next_run, GC_SCAN_INTERVAL_MIN, GC_SCAN_INTERVAL_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 delta_time</span></span><br><span class="line">    delta_time = <span class="type">max_t</span>(s32, nfct_time_stamp - gc_work-&gt;start_time, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (next_run &gt; (<span class="type">unsigned</span> <span class="type">long</span>)delta_time)</span><br><span class="line">        next_run -= delta_time;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next_run = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">early_exit:</span><br><span class="line">    <span class="comment">// 如果正在退出，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (gc_work-&gt;exiting)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下次运行时间不为零，重置 early_drop 标志</span></span><br><span class="line">    <span class="keyword">if</span> (next_run)</span><br><span class="line">        gc_work-&gt;early_drop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调度工作</span></span><br><span class="line">    queue_delayed_work(system_power_efficient_wq, &amp;gc_work-&gt;dwork, next_run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-questions"><a href="#4-questions" class="headerlink" title="4. questions"></a>4. questions</h1><ol>
<li>conntrack -L 的实现中， 直接遍历了 <code>nf_conntrack_hash</code>，这里面并不包含 confirmed list，那么 conntrack -L 中是如何看到 unconfirmed conntrack entry 的呢</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ctnetlink_dump_table</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> netlink_callback *cb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags = cb-&gt;data ? NLM_F_DUMP_FILTERED : <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *<span class="title">h</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">n</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">nf_ct_evict</span>[8];</span></span><br><span class="line">	<span class="type">int</span> res, i;</span><br><span class="line">	<span class="type">spinlock_t</span> *lockp;</span><br><span class="line"></span><br><span class="line">	last = (<span class="keyword">struct</span> nf_conn *)cb-&gt;args[<span class="number">1</span>];</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	local_bh_disable();</span><br><span class="line">	<span class="keyword">for</span> (; cb-&gt;args[<span class="number">0</span>] &lt; nf_conntrack_htable_size; cb-&gt;args[<span class="number">0</span>]++) &#123;</span><br><span class="line">restart:</span><br><span class="line">		<span class="keyword">while</span> (i) &#123;</span><br><span class="line">			i--;</span><br><span class="line">			<span class="keyword">if</span> (nf_ct_should_gc(nf_ct_evict[i]))</span><br><span class="line">				nf_ct_kill(nf_ct_evict[i]);</span><br><span class="line">			nf_ct_put(nf_ct_evict[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lockp = &amp;nf_conntrack_locks[cb-&gt;args[<span class="number">0</span>] % CONNTRACK_LOCKS];</span><br><span class="line">		nf_conntrack_lock(lockp);</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;args[<span class="number">0</span>] &gt;= nf_conntrack_htable_size) &#123;</span><br><span class="line">			spin_unlock(lockp);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		hlist_nulls_for_each_entry(h, n, &amp;nf_conntrack_hash[cb-&gt;args[<span class="number">0</span>]],</span><br><span class="line">					   hnnode) &#123;</span><br><span class="line">			ct = nf_ct_tuplehash_to_ctrack(h);</span><br><span class="line">			<span class="keyword">if</span> (nf_ct_is_expired(ct)) &#123;</span><br><span class="line">				<span class="comment">/* need to defer nf_ct_kill() until lock is released */</span></span><br><span class="line">				<span class="keyword">if</span> (i &lt; ARRAY_SIZE(nf_ct_evict) &amp;&amp;</span><br><span class="line">				    refcount_inc_not_zero(&amp;ct-&gt;ct_general.use))</span><br><span class="line">					nf_ct_evict[i++] = ct;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!net_eq(net, nf_ct_net(ct)))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (NF_CT_DIRECTION(h) != IP_CT_DIR_ORIGINAL)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cb-&gt;args[<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ct != last)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				cb-&gt;args[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ctnetlink_filter_match(ct, cb-&gt;data))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			res =</span><br><span class="line">			ctnetlink_fill_info(skb, NETLINK_CB(cb-&gt;skb).portid,</span><br><span class="line">					    cb-&gt;nlh-&gt;nlmsg_seq,</span><br><span class="line">					    NFNL_MSG_TYPE(cb-&gt;nlh-&gt;nlmsg_type),</span><br><span class="line">					    ct, <span class="literal">true</span>, flags);</span><br><span class="line">			<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				nf_conntrack_get(&amp;ct-&gt;ct_general);</span><br><span class="line">				cb-&gt;args[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)ct;</span><br><span class="line">				spin_unlock(lockp);</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(lockp);</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;args[<span class="number">1</span>]) &#123;</span><br><span class="line">			cb-&gt;args[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	local_bh_enable();</span><br><span class="line">	<span class="keyword">if</span> (last) &#123;</span><br><span class="line">		<span class="comment">/* nf ct hash resize happened, now clear the leftover. */</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">struct</span> nf_conn *)cb-&gt;args[<span class="number">1</span>] == last)</span><br><span class="line">			cb-&gt;args[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		nf_ct_put(last);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i) &#123;</span><br><span class="line">		i--;</span><br><span class="line">		<span class="keyword">if</span> (nf_ct_should_gc(nf_ct_evict[i]))</span><br><span class="line">			nf_ct_kill(nf_ct_evict[i]);</span><br><span class="line">		nf_ct_put(nf_ct_evict[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> skb-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol>
<li>在 6.x 的 kernel 中移出了 uncofirmed list 等，使用 ecache 机制 <a target="_blank" rel="noopener" href="https://patchwork.ozlabs.org/project/netfilter-devel/patch/20220510122150.92533-2-pablo@netfilter.org/">https://patchwork.ozlabs.org/project/netfilter-devel/patch/20220510122150.92533-2-pablo@netfilter.org/</a> </li>
<li>5.x 版本 conntrack 实现详解 <a target="_blank" rel="noopener" href="https://thermalcircle.de/doku.php?id=blog:linux:connection_tracking_2_core_implementation">https://thermalcircle.de/doku.php?id=blog:linux:connection_tracking_2_core_implementation</a></li>
<li><a target="_blank" rel="noopener" href="https://arthurchiao.art/blog/conntrack-design-and-implementation-zh/#3-netfilter-conntrack-%E5%AE%9E%E7%8E%B0">https://arthurchiao.art/blog/conntrack-design-and-implementation-zh/#3-netfilter-conntrack-%E5%AE%9E%E7%8E%B0</a></li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-purpose"><span class="toc-number">1.</span> <span class="toc-text">1. purpose</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Overview"><span class="toc-number">2.</span> <span class="toc-text">2. Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Conntrack-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">3. Conntrack 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 相关数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 大致流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-ct-connection-lifecycle"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 ct connection lifecycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-nf-conntrack-in%EF%BC%9A%E8%BF%9B%E5%85%A5%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 nf_conntrack_in：进入连接跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-resolve-normal-ct-%E5%A4%84%E7%90%86%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 resolve_normal_ct: 处理新连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-nf-conntrack-confirm%EF%BC%9A%E7%A1%AE%E8%AE%A4%E5%8C%85%E5%8A%A0%E5%85%A5-conntrack-table"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 nf_conntrack_confirm：确认包加入 conntrack table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-connection-%E7%9A%84timeout%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8Cgc"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 connection 的timeout，删除，gc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-nf-conn-%E9%87%8A%E6%94%BE"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 nf_conn 释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-conntrack-timeout"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 conntrack timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-conntrack-gc"><span class="toc-number">3.7.3.</span> <span class="toc-text">3.7.3 conntrack gc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-questions"><span class="toc-number">4.</span> <span class="toc-text">4. questions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">5.</span> <span class="toc-text">reference</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&text=conntrack demystify"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&is_video=false&description=conntrack demystify"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=conntrack demystify&body=Check out this article: https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&title=conntrack demystify"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&name=conntrack demystify&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://middaywords.github.io/2024/12/13/2024-1213-conntrack-demystify/&t=conntrack demystify"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Kangjie Xu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
