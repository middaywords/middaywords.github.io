<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="这位博主将 调度系列 中将 CFS 的实现解析得非常详尽， 在这篇文章里，我们则关注 sched core 和 sched cfs 之间的接口交互。 (这篇文章后面没细致写了，感觉这样写脉络不是很清晰。还是从一个 task_group 被 fork 以及被kill 开始说 0. basic concepts调度类需要实现的所有接口定义在 struct sched_class 里。下面对其中最重要的">
<meta property="og:type" content="article">
<meta property="og:title" content="about scheduler interface">
<meta property="og:url" content="https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/index.html">
<meta property="og:site_name" content="Kangjie&#39;s Homepage">
<meta property="og:description" content="这位博主将 调度系列 中将 CFS 的实现解析得非常详尽， 在这篇文章里，我们则关注 sched core 和 sched cfs 之间的接口交互。 (这篇文章后面没细致写了，感觉这样写脉络不是很清晰。还是从一个 task_group 被 fork 以及被kill 开始说 0. basic concepts调度类需要实现的所有接口定义在 struct sched_class 里。下面对其中最重要的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1414775/202002/1414775-20200221182836700-577726174.png">
<meta property="article:published_time" content="2025-01-12T10:44:04.000Z">
<meta property="article:modified_time" content="2025-02-22T15:29:41.465Z">
<meta property="article:author" content="Kangjie Xu">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="sched">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/i-beta/1414775/202002/1414775-20200221182836700-577726174.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>about scheduler interface</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2025/02/19/2025-0219-rcu-basics/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2025/01/06/2025-0106-tcp-tuning/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&text=about scheduler interface"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&is_video=false&description=about scheduler interface"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=about scheduler interface&body=Check out this article: https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&name=about scheduler interface&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&t=about scheduler interface"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-basic-concepts"><span class="toc-number">1.</span> <span class="toc-text">0. basic concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-schedule-%E8%B0%83%E5%BA%A6%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.</span> <span class="toc-text">1. schedule() 调度核心逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-enqueue-task-%E8%BF%9B%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">2.  enqueue_task - 进程加入运行队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-task-tick"><span class="toc-number">4.</span> <span class="toc-text">3. task_tick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-dequeue-task"><span class="toc-number">5.</span> <span class="toc-text">4. dequeue_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-yield-task"><span class="toc-number">6.</span> <span class="toc-text">5. yield_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-wakeup-preempt"><span class="toc-number">7.</span> <span class="toc-text">6. wakeup_preempt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-put-prev-task-set-next-task-pick-task"><span class="toc-number">8.</span> <span class="toc-text">7 put_prev_task &amp; set_next_task &amp; pick_task()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-select-task-rq"><span class="toc-number">9.</span> <span class="toc-text">8. select_task_rq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-migrate-task-rq-balance"><span class="toc-number">10.</span> <span class="toc-text">9. migrate_task_rq &amp; balance</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        about scheduler interface
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Kangjie Xu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-01-12T10:44:04.000Z" class="dt-published" itemprop="datePublished">2025-01-12</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/kernel/" rel="tag">kernel</a>, <a class="p-category" href="/tags/linux/" rel="tag">linux</a>, <a class="p-category" href="/tags/sched/" rel="tag">sched</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>这位博主将 <a target="_blank" rel="noopener" href="https://hackmd.io/@RinHizakura?tags=%5B%22Scheduler%22%5D">调度系列</a> 中将 CFS 的实现解析得非常详尽，</p>
<p>在这篇文章里，我们则关注 sched core 和 sched cfs 之间的接口交互。</p>
<p>(这篇文章后面没细致写了，感觉这样写脉络不是很清晰。还是从一个 task_group 被 fork 以及被kill 开始说</p>
<h2 id="0-basic-concepts"><a href="#0-basic-concepts" class="headerlink" title="0. basic concepts"></a>0. basic concepts</h2><p>调度类需要实现的所有接口定义在 struct sched_class 里。下面对其中最重要的一些调度类接口做简单的介绍:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	<span class="type">int</span> uclamp_enabled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">void</span> (*yield_task)   (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">	<span class="type">bool</span> (*yield_to_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">  </span><br><span class="line">	<span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">  </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*put_prev_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">	<span class="type">void</span> (*set_next_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> first);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span> (*balance)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf);</span><br><span class="line">	<span class="type">int</span>  (*select_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> task_cpu, <span class="type">int</span> flags);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*migrate_task_rq)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> new_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*task_woken)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*set_cpus_allowed)(<span class="keyword">struct</span> task_struct *p,</span><br><span class="line">				 <span class="type">const</span> <span class="keyword">struct</span> cpumask *newmask,</span><br><span class="line">				 u32 flags);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*rq_online)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">	<span class="type">void</span> (*rq_offline)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *(*<span class="title">find_lock_rq</span>)(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*task_tick)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">	<span class="type">void</span> (*task_fork)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">	<span class="type">void</span> (*task_dead)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span></span><br><span class="line"><span class="comment">	 * cannot assume the switched_from/switched_to pair is serialized by</span></span><br><span class="line"><span class="comment">	 * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*switched_from)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">	<span class="type">void</span> (*switched_to)  (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">	<span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">			      <span class="type">int</span> oldprio);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span><span class="params">(<span class="keyword">struct</span> rq *rq,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (*update_curr)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SET_GROUP		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_MOVE_GROUP		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="type">void</span> (*task_change_group)(<span class="keyword">struct</span> task_struct *p, <span class="type">int</span> type);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>enqueue_task</code>: Called when a task enters a runnable state. It puts the scheduling entity (task) into the red-black tree and increments the nr_running variable. 将待运行的任务插入到per-cpu rq。向就绪队列中添加一个任务，当某个任务进入可运行状态时，调用这个函数。典型的场景就是内核里的唤醒函数，将被唤醒的任务插入rq然后设置任务运行态为 TASK_RUNNING。对 CFS 调度器来说，则是将任务插入红黑树，给 nr_running 增加计数。</li>
<li><code>dequeue_task</code>: When a task is no longer runnable, this function is called to keep the corresponding scheduling entity out of the red-black tree. It decrements the nr_running variable. 将非运行态任务移除出per-cpu rq。将一个任务从就绪队列中删除，典型的场景就是任务调度引起阻塞的内核函数，把任务运行态设置成 TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE，然后调用 schedule 函数，最终触发dequeue_task的操作。对 CFS 调度器来说，则是将不在处于运行态的任务从红黑树中移除，给 nr_running 减少计数。</li>
</ul>
<ul>
<li>yield_task：This function is basically just a dequeue followed by an enqueue, unless the compat_yield sysctl is turned on; in that case, it places the scheduling entity at the right-most end of the red-black tree. 处于运行态的任务主动让出 CPU。典型的场景就是处于运行态的应用调用sched_yield系统调用，直接让出 CPU。此时系统调用 sched_yield 系统调用先调用 yield_task 申请让出 CPU，然后调用 schedule 去做上下文切换。对 CFS 调度器来说，如果 nr_running 是 1，则直接返回，最终 schedule 函数也不产生上下文切换。否则，任务被标记为skip 状态。调度器在红黑树上选择待运行任务时肯定会跳过该任务。之后，因为 schedule 函数被调用，pick_next_task 最终会被调用。其代码会从红黑树中最左侧选择一个任务，然后把要放弃运行的任务放回红黑树，然后调用上下文切换函数做任务上下文切换。</li>
<li>yield_to_task：让处于运行态的任务主动放弃CPU，并执行指定的任务。</li>
<li>check_preempt_curr：用于在待运行任务插入rq后，检查是否应该抢占正在CPU上运行的当前任务。Wakeup Preemption 的实现逻辑主要在这里。对 CFS 调度器而言，主要是在是否能满足调度时延和是否能保证足够任务运行时间之间来取舍。CFS 调度器也提供了预定义的 Threshold 允许做 Wakeup Preemption 的调用</li>
<li>pick_next_task：This function chooses the most appropriate task eligible to run next. 选择下一个最适合调度运行的任务，将其从rq移除。并且如果前一个任务还保持在运行态，即没有从rq移除，则将当前的任务重新放回到rq。内核 schedule 函数利用它来完成调度时任务的选择。对CFS调度器而言，大多数情况下，下一个调度任务是从红黑树的最左侧节点选择并移除。如果前一个任务是其它调度类，则调用该调度类的 put_prev_task 方法将前一个任务做正确的安置处理。但如果前一个任务如果也属于CFS调度类的话，为了效率，跳过调度类标准方法 put_prev_task，但核心逻辑仍旧是 put_prev_task_fair 的主要部分。</li>
<li>put_prev_task：将前一个正在CPU上运行的任务从CPU上拿下的处理。如果任务还在运行态则将任务放回rq，否则，根据调度类要求做简单处理。此函数通常是 pick_next_task 的密切关联操作，是 schedule 实现的关键部分。如果前一个任务属于CFS调度类，则使用CFS调度类的具体实现 put_prev_task_fair。此时，如果任务还是 TASK_RUNNING 状态，则被重新插入到红黑树的最右侧。如果这个任务不是 TASK_RUNNING 状态，则已经从红黑树移除过了，只需要修改CFS 当前任务指针 cfs_rq-&gt;curr 即可。</li>
<li>select_task_rq：为给定的任务选择一个最优的CPU就绪队列rq，返回rq所属的CPU号。典型的使用场景是唤醒，fork&#x2F;exec 进程时，给进程选择一个rq，这也给调度器一个CPU负载均衡的机会。对CFS调度器而言，主要是根据传入的参数要求找到符合亲和性要求的最空闲的CPU所属的rq。</li>
<li>task_dead：进程结束时调用。</li>
<li>switched_from：用于切换调度类。</li>
<li>switched_to：切换到下一个进程来运行。</li>
<li>prio_changed：改变进程优先级。</li>
<li><code>task_tick</code>: This function is mostly called from time tick functions; it might lead to process switch. This drives the running preemption.</li>
</ul>
<h2 id="1-schedule-调度核心逻辑"><a href="#1-schedule-调度核心逻辑" class="headerlink" title="1. schedule() 调度核心逻辑"></a>1. schedule() 调度核心逻辑</h2><p>调度子系统的核心逻辑在 <code>__schedule()</code> 中，进入该函数有三种主要的方式</p>
<ol>
<li>显式阻塞</li>
<li>返回 userspace 的时候，检查 TIF_NEED_RESCHED 标志后会调用。</li>
<li>任务唤醒</li>
</ol>
<p>并且调用该函数的时候，要保证禁用抢占。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __schedule() is the main scheduler function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The main means of driving the scheduler and thus entering this function are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return</span></span><br><span class="line"><span class="comment"> *      paths. For example, see arch/x86/entry_64.S.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      To drive preemption between tasks, the scheduler sets the flag in timer</span></span><br><span class="line"><span class="comment"> *      interrupt handler sched_tick().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   3. Wakeups don&#x27;t really cause entry into schedule(). They add a</span></span><br><span class="line"><span class="comment"> *      task to the run-queue and that&#x27;s it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Now, if the new task added to the run-queue preempts the current</span></span><br><span class="line"><span class="comment"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets</span></span><br><span class="line"><span class="comment"> *      called on the nearest possible occasion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is preemptible (CONFIG_PREEMPTION=y):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in syscall or exception context, at the next outmost</span></span><br><span class="line"><span class="comment"> *           preempt_enable(). (this might be as soon as the wake_up()&#x27;s</span></span><br><span class="line"><span class="comment"> *           spin_unlock()!)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in IRQ context, return from interrupt-handler to</span></span><br><span class="line"><span class="comment"> *           preemptible context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is not preemptible (CONFIG_PREEMPTION is not set)</span></span><br><span class="line"><span class="comment"> *         then at the next:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          - cond_resched() call</span></span><br><span class="line"><span class="comment"> *          - explicit schedule() call</span></span><br><span class="line"><span class="comment"> *          - return from syscall or exception to user-space</span></span><br><span class="line"><span class="comment"> *          - return from interrupt-handler to user-space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: must be called with preemption disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace __schedule(<span class="type">unsigned</span> <span class="type">int</span> sched_mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> prev_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前 cpu 的编号</span></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">  <span class="comment">// 当前 cpu 运行队列</span></span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">  <span class="comment">// 当前正在运行的任务</span></span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	schedule_debug(prev, !!sched_mode);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用了高分辨率定时器功能，则清除高分辨率定时器。</span></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK) || sched_feat(HRTICK_DL))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 禁用本地中断 &amp; 记录上下文切换信息。</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	rcu_note_context_switch(!!sched_mode);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 锁定运行队列，并在自旋锁后执行内存屏障，确保操作顺序。</span></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">  <span class="comment">// 更新运行队列的时钟标志和时钟。</span></span><br><span class="line">	rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	rq-&gt;clock_update_flags = RQCF_UPDATED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化切换计数指针，指向非自愿上下文切换计数。</span></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 读取前一个任务的状态。</span></span><br><span class="line">	prev_state = READ_ONCE(prev-&gt;__state);</span><br><span class="line">  <span class="comment">// 如果前一个任务不可抢占且有挂起的信号，则将其状态设置为运行中。</span></span><br><span class="line">  <span class="comment">// 否则，检查任务是否对负载有贡献，并在必要时增加不可中断任务计数。</span></span><br><span class="line">  <span class="comment">// 然后将任务从运行队列中移除，并在任务等待I/O时增加I/O等待计数。</span></span><br><span class="line">	<span class="keyword">if</span> (!(sched_mode &amp; SM_MASK_PREEMPT) &amp;&amp; prev_state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(prev_state, prev)) &#123;</span><br><span class="line">			WRITE_ONCE(prev-&gt;__state, TASK_RUNNING);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			prev-&gt;sched_contributes_to_load =</span><br><span class="line">				(prev_state &amp; TASK_UNINTERRUPTIBLE) &amp;&amp;</span><br><span class="line">				!(prev_state &amp; TASK_NOLOAD) &amp;&amp;</span><br><span class="line">				!(prev_state &amp; TASK_FROZEN);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;sched_contributes_to_load)</span><br><span class="line">				rq-&gt;nr_uninterruptible++;</span><br><span class="line"></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">				<span class="type">atomic_inc</span>(&amp;rq-&gt;nr_iowait);</span><br><span class="line">				delayacct_blkio_start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择下一个要运行的任务。</span></span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">  <span class="comment">// 清除需要重新调度的标志。</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">  <span class="comment">// 如果启用了调度调试，则重置最后一次需要重新调度的时间戳。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	rq-&gt;last_seen_need_resched_ns = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果前一个任务和下一个任务不同，则执行上下文切换，更新运行队列的当前任务指针，</span></span><br><span class="line">  <span class="comment">// 增加切换计数，并处理各种记账任务。最后，调用context_switch()函数进行实际的上下文切换。</span></span><br><span class="line">  <span class="comment">// 如果前一个任务和下一个任务相同，则解锁运行队列并执行必要的回调。</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		RCU_INIT_POINTER(rq-&gt;curr, next);</span><br><span class="line">		++*switch_count;</span><br><span class="line"></span><br><span class="line">		migrate_disable_switch(rq, prev);</span><br><span class="line">		psi_account_irqtime(rq, prev, next);</span><br><span class="line">		psi_sched_switch(prev, next, !task_on_rq_queued(prev));</span><br><span class="line"></span><br><span class="line">		trace_sched_switch(sched_mode &amp; SM_MASK_PREEMPT, prev, next, prev_state);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq_unpin_lock(rq, &amp;rf);</span><br><span class="line">		__balance_callbacks(rq);</span><br><span class="line">		raw_spin_rq_unlock_irq(rq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-enqueue-task-进程加入运行队列"><a href="#2-enqueue-task-进程加入运行队列" class="headerlink" title="2.  enqueue_task - 进程加入运行队列"></a>2.  enqueue_task - 进程加入运行队列</h2><p>Called when a task enters a runnable state. It puts the scheduling entity (task) into the red-black tree and increments the nr_running variable.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">enqueue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_RESTORE)) &#123;</span><br><span class="line">		sched_info_enqueue(rq, p);</span><br><span class="line">		psi_enqueue(p, (flags &amp; ENQUEUE_WAKEUP) &amp;&amp; !(flags &amp; ENQUEUE_MIGRATED));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_inc(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_core_enabled(rq))</span><br><span class="line">		sched_core_enqueue(rq, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">activate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_migrating(p))</span><br><span class="line">		flags |= ENQUEUE_MIGRATED;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ENQUEUE_MIGRATED)</span><br><span class="line">		sched_mm_cid_migrate_to(rq, p);</span><br><span class="line"></span><br><span class="line">	enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(p-&gt;on_rq, TASK_ON_RQ_QUEUED);</span><br><span class="line">	ASSERT_EXCLUSIVE_WRITER(p-&gt;on_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><code>wake_up_new_task</code>:  <strong>将新创建的进程加入就绪队列，等待调度</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// a. 为进程选择一个合适的 CPU</span></span><br><span class="line">  <span class="comment">// b. 为进程指定运行队列</span></span><br><span class="line">  __set_task_cpu(p, select_task_rq(p, task_cpu(p), WF_FORK));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// c. 将进程添加到运行队列</span></span><br><span class="line">  rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">  activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a. 调用 <code>sched_class-&gt;select_task_rq()</code> 方法来选择选择合适的 CPU</p>
<ul>
<li>对于 fair scheduler，我们使用 <code>select_task_rq_fair</code>。先考虑使用上一次进程使用的 CPU 逻辑核，或者要唤醒它的物理核的另一个逻辑核。这两个核的缓存大概还是热数据，调度上去执行较快。</li>
<li>再考虑调度到相邻共享缓存且 idle 的 CPU。会有两种 path</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">select_task_rq_fair</span><span class="params">(...)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(sd)) &#123;</span><br><span class="line">		<span class="comment">/* Slow path */</span></span><br><span class="line">		new_cpu = find_idlest_cpu(sd, p, cpu, prev_cpu, sd_flag);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wake_flags &amp; WF_TTWU) &#123; <span class="comment">/* XXX always ? */</span></span><br><span class="line">		<span class="comment">/* Fast path */</span></span><br><span class="line">		new_cpu = select_idle_sibling(p, prev_cpu, new_cpu);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 slow path，会去找负载最小的组。再 fastpath，会考虑共享缓存且 idle 的 CPU，优先选择任务上次运行的 CPU。</li>
</ul>
<p>b. 指定运行队列，绑定到某个 <code>struct rq</code></p>
<p>c. enqueue task: 调用 <code>activate_task()</code> -&gt; <code>p-&gt;sched_class-&gt;enqueue_task(...)</code></p>
<ol start="2">
<li>不同核之间发生 migration</li>
</ol>
<p>move_queued_task: 把已经运行的进程迁移到指定的 CPU 可运行队列中，比如在 set affinity 的时候会调用这个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rq *<span class="title function_">move_queued_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> rq_flags *rf,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> new_cpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  rq_lock(rq, rf);</span><br><span class="line">	WARN_ON_ONCE(task_cpu(p) != new_cpu);</span><br><span class="line">	activate_task(rq, p, <span class="number">0</span>);</span><br><span class="line">	wakeup_preempt(rq, p, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Wake up a thread</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_wake_up - wake up a thread</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">try_to_wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">int</span> state, <span class="type">int</span> wake_flags)</span> */</span><br></pre></td></tr></table></figure>

<p>当一个进程在等待一个 I&#x2F;O 的时候，会主动放弃 CPU。但是当 I&#x2F;O 到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。try_to_wake_up() 调用 ttwu_queue 将这个唤醒的任务添加到队列当中。ttwu_queue 再调用 ttwu_do_activate 激活这个任务。</p>
<p>在 ttwu_do_activate 中，首先调用 activate_task 加入 sched_class 的 cfs_rq 中，然后 ttwu_do_activate 调用 ttwu_do_wakeup，将任务标记为可以运行的。到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。在 <strong>3 taks_tick</strong> 中我们会解释这一点。</p>
<h2 id="3-task-tick"><a href="#3-task-tick" class="headerlink" title="3. task_tick"></a>3. task_tick</h2><p>常见的现象就是<strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong>。那怎么衡量一个进程的运行时间呢？</p>
<p>在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。时钟中断处理函数会调用 scheduler_tick()，它的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scheduler_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">  curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line">  cpu_load_update_active(rq);</span><br><span class="line">  calc_global_load_tick(rq);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前运行的进程是普通进程，调度类为 fair_sched_class，调用的处理时钟的函数为 task_tick_fair。我们来看一下它的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tick_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;</span><br><span class="line">  for_each_sched_entity(se) &#123;</span><br><span class="line">    cfs_rq = cfs_rq_of(se);</span><br><span class="line">    entity_tick(cfs_rq, se, queued);</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据当前进程的 task_struct，找到对应的调度实体 sched_entity 和 cfs_rq 队列，调用 entity_tick。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">entity_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">  update_curr(cfs_rq);</span><br><span class="line">  update_load_avg(curr, UPDATE_TG);</span><br><span class="line">  update_cfs_shares(curr);</span><br><span class="line">.....</span><br><span class="line">  <span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">    check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 entity_tick 里面，我们又见到了熟悉的 update_curr。它会更新当前进程的 vruntime，然后调用 check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">  s64 delta;</span><br><span class="line">  ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">  delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line">  <span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span><br><span class="line">    resched_curr(rq_of(cfs_rq));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  se = __pick_first_entity(cfs_rq);</span><br><span class="line">  delta = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line">  <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (delta &gt; ideal_runtime)</span><br><span class="line">    resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>check_preempt_tick 先是调用 sched_slice 函数计算出的 ideal_runtime。ideal_runtime 是一个调度周期中，该进程运行的实际时间。</p>
<p>sum_exec_runtime 指进程总共执行的实际时间，prev_sum_exec_runtime 指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的 se-&gt;prev_sum_exec_runtime &#x3D; se-&gt;sum_exec_runtime，所以 sum_exec_runtime-prev_sum_exec_runtime 就是这次调度占用实际时间。如果这个时间大于 ideal_runtime，则应该被抢占了。</p>
<p>除了这个条件之外，还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了。</p>
<p><strong>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用 __schedule 才行啊，所以这里只能先标记一下</strong>。</p>
<p>标记一个进程应该被抢占，都是调用 resched_curr，它会调用 set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签 TIF_NEED_RESCHED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_tsk_need_resched</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">  set_tsk_thread_flag(tsk,TIF_NEED_RESCHED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个可能抢占的场景是<strong>当一个进程被唤醒的时候</strong>。即我们再 <strong>2 enqueue_task</strong> 中提到的 try_to_wake_up 相关的实现。</p>
<p>有位博主用了思维图来描述，总结得很好，借用一下：cr: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mysky007/p/12342505.html">https://www.cnblogs.com/mysky007/p/12342505.html</a></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1414775/202002/1414775-20200221182836700-577726174.png" alt="img"></p>
<blockquote>
<p>调度, 切换运行进程, 有两种方式<br>  - 进程调用 sleep 或等待 I&#x2F;O, 主动让出 CPU<br>  - 进程运行一段时间, 被动让出 CPU<br>主动让出 CPU 的方式, 调用 schedule(), schedule() 调用 __schedule()<br>  - __schedule() 取出 rq; 取出当前运行进程的 task_struct<br>  - 调用 pick_next_task 取下一个进程<br>    - 依次调用调度类(优化: 大部分都是普通进程), 因此大多数情况调用 fair_sched_class.pick_next_task[_fair]<br>    - pick_next_task_fair 先取出 cfs_rq 队列, 取出当前运行进程调度实体, 更新 vruntime<br>    - pick_next_entity 取最左节点, 并得到 task_struct, 若与当前进程不一样, 则更新红黑树 cfs_rq<br>  - 进程上下文切换: 切换进程内存空间, 切换寄存器和 CPU 上下文(运行 context_switch)<br>    - context_switch() -&gt; switch_to() -&gt; __switch_to_asm(切换[内核]栈顶指针) -&gt; __switch_to()<br>    - switch_to() 取出 Per CPU 的 tss(任务状态段) 结构体<br>    - &gt; x86 提供以硬件方式切换进程的模式, 为每个进程在内存中维护一个 tss, tss 有所有寄存器, 同时 TR(任务寄存器)指向某个 tss, 更改 TR 会触发换出 tss(旧进程)和换入 tss(新进程), 但切换进程没必要换所有寄存器<br>    - 因此 Linux 中每个 CPU 关联一个 tss, 同时 TR 不变, Linux 中参与进程切换主要是栈顶寄存器<br>    - task_struct 的 thread 结构体保留切换时需要修改的寄存器, 切换时将新进程 thread 写入 CPU tss 中<br>    - 具体各类指针保存位置和时刻<br>      - 用户栈, 切换进程内存空间时切换<br>      - 用户栈顶指针, 内核栈 pt_regs 中弹出<br>      - 用户指令指针, 从内核栈 pt_regs 中弹出<br>      - 内核栈, 由切换的 task_struct 中的 stack 指针指向<br>      - 内核栈顶指针, switch_to_asm 函数切换(保存在 thread 中)<br>      - 内核指令指针寄存器: 进程调度最终都会调用 __schedule, 因此在让出(从当前进程)和取得(从其他进程) CPU 时, 该指针都指向同一个代码位置.</p>
</blockquote>
<p>preemption 更多相关的在 <strong>6. wakeup_preempt</strong> 里面有提到</p>
<h2 id="4-dequeue-task"><a href="#4-dequeue-task" class="headerlink" title="4. dequeue_task"></a>4. dequeue_task</h2><p>与 enqueue_task 类似，它表示 task 被移出调度队列。</p>
<p>主调度器的入口函数是<code>schedule</code>，在内核中，当需要将CPU分配给与当前进程不同的另一个进程时，就会调用<code>schedule</code>函数来选择下一个可执行进程。<code>schedule</code>函数最终调用的是<code>__schedule</code>函数，所以这里将<code>__schedule</code>函数拆分来讲解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace __schedule(<span class="type">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;	<span class="comment">/* 1 */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);	<span class="comment">/* 2 */</span></span><br><span class="line">			prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf);	<span class="comment">/* 3 */</span></span><br><span class="line">	clear_tsk_need_resched(prev);	<span class="comment">/* 4 */</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);	<span class="comment">/* 5 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前进程处于可中断的睡眠状态，同时现在接收到了信号，那么将再次被提升为可运行进程。</li>
<li>否则就调用<code>deactivate_task</code>函数将当前进程变成不活跃状态，这个函数最终会调用调度器类的<code>dequeue_task</code>完成删除运行队列的进程的工作。将进程的on_rq标志位置为0，表示不在就绪队列上了。</li>
<li>调用<code>pick_next_task</code>函数选择下一个执行的进程。</li>
<li>清除当前进程的<code>TIF_NEED_RESCHED</code>标志位，意味着不需要重调度。</li>
<li>如果下一个被调度执行进程不是当前进程，调用<code>context_switch</code>函数进行进程上下文切换。</li>
</ul>
<h2 id="5-yield-task"><a href="#5-yield-task" class="headerlink" title="5. yield_task"></a>5. yield_task</h2><p>在进程想要自愿放弃对处理器的控制权时，可以使用 sched_yield 系统调用。这导致内核调用yield_task。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(sched_yield)</span><br><span class="line">&#123;</span><br><span class="line">	do_sched_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_sched_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = this_rq_lock_irq(&amp;rf);</span><br><span class="line"></span><br><span class="line">	schedstat_inc(rq-&gt;yld_count);</span><br><span class="line">	current-&gt;sched_class-&gt;yield_task(rq);</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rq = this_rq_lock_irq(&amp;rf);</code>: 拿到当前 cpu 所在核的 rq</li>
<li><code>current-&gt;sched_class-&gt;yield_task(rq);</code>:  对 rq 执行 yield_task</li>
<li><code>schedule()</code>: 执行下一次调度</li>
</ul>
<p>会调用到 sched_class 的 yield_task 接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">yield_task_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> task_cfs_rq(curr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Are we the only task in the tree?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rq-&gt;nr_running == <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	clear_buddies(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update run-time statistics of the &#x27;current&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tell update_rq_clock() that we&#x27;ve just updated,</span></span><br><span class="line"><span class="comment">	 * so we don&#x27;t do microscopic update in schedule()</span></span><br><span class="line"><span class="comment">	 * and double the fastpath cost.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_clock_skip_update(rq);</span><br><span class="line"></span><br><span class="line">	se-&gt;deadline += calc_delta_fair(se-&gt;slice, se);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __clear_buddies_next(<span class="keyword">struct</span> sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	for_each_sched_entity(se) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> cfs_rq_of(se);</span><br><span class="line">		<span class="keyword">if</span> (cfs_rq-&gt;next != se)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		cfs_rq-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">clear_buddies</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;next == se)</span><br><span class="line">		__clear_buddies_next(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (unlikely(rq-&gt;nr_running == 1))</code> : 如果 rq 里面只有一个进程，直接返回。</li>
<li><code>clear_buddies(cfs_rq, se);</code>: 如果下一个准备调度的 sched_entity 是当前 task_struct，则设成空。（下一次不要调度当前 task</li>
<li><code>update_rq_clock(rq);</code> &amp; <code>update_curr(cfs_rq);</code>: 更新当前 CFS 数据，时钟，运行时间等。</li>
</ul>
<p>简而言之，<code>yield_task</code> 就是，如果当前进程对应的 se 是 cfs_rq 下一个要调度的对象，就拿走，并调用 <code>schedule()</code> 立即启动下一轮调度。</p>
<h2 id="6-wakeup-preempt"><a href="#6-wakeup-preempt" class="headerlink" title="6. wakeup_preempt"></a>6. wakeup_preempt</h2><p>This function checks if a task that entered the runnable state should preempt the currently running task.</p>
<p>之前这个函数叫 <code>check_preempt_curr</code>，后面改名了。</p>
<p>大多被调用的情况是， <code>activate_task</code> 之后，即 <code>enqueue_task</code> 被调用之后，则会调用到 <code>wakeup_preempt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wakeup_preempt</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class)</span><br><span class="line">		rq-&gt;curr-&gt;sched_class-&gt;wakeup_preempt(rq, p, flags);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sched_class_above(p-&gt;sched_class, rq-&gt;curr-&gt;sched_class))</span><br><span class="line">		resched_curr(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A queue event has occurred, and we&#x27;re going to schedule.  In</span></span><br><span class="line"><span class="comment">	 * this case, we can save a useless back to back clock update.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(rq-&gt;curr) &amp;&amp; test_tsk_need_resched(rq-&gt;curr))</span><br><span class="line">		rq_clock_skip_update(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到的被调用的有几种情况</p>
<ol>
<li><code>wake_up_new_task</code>: 当新 task_struct 被调用后，os 会先 <code>activate_task</code>，加入 cfs_rq 之后再调用 <code>wakeup_preempt</code>。</li>
<li><code>try_to_wake_up</code> -&gt;  <code>ttwu_runnable</code>: <code>try_to_wake_up</code> 的时候，发现 task_struct 已经在某个 rq 中。</li>
<li><code>try_to_wake_up</code> -&gt; <code>ttwu_do_activate</code>: <code>try_to_wake_up</code> 的时候，走常规流程，先 <code>enqueue_task</code>，然后 <code>wakeup_preempt</code>。</li>
<li><code>__migrate_swap_task</code>&#x2F;<code>move_queued_task</code>: 核间 load balance 的时候，涉及到 activate task，完成后会调用 <code>wakeup_preempt</code></li>
</ol>
<p>在之前我们提到 preemption 其实在之前，只是标记了一下。</p>
<blockquote>
<p> 一个进程应该被抢占，都是调用 resched_curr，它会调用 set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签 TIF_NEED_RESCHED。</p>
</blockquote>
<p>在这里 wakeup_preempt 的实现里面，最终的判定结果是需要抢占的话，也是执行 <code>resched_curr</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Preempt the current task with a newly woken task if needed:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_preempt_wakeup_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se, *pse = &amp;p-&gt;se;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> task_cfs_rq(curr);</span><br><span class="line">	<span class="type">int</span> cse_is_idle, pse_is_idle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(se == pse))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Idle tasks are by definition preempted by non-idle tasks. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(task_has_idle_policy(curr)) &amp;&amp;</span><br><span class="line">	    likely(!task_has_idle_policy(p)))</span><br><span class="line">		<span class="keyword">goto</span> preempt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cse_is_idle = se_is_idle(se);</span><br><span class="line">	pse_is_idle = se_is_idle(pse);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Preempt an idle group in favor of a non-idle group (and don&#x27;t preempt</span></span><br><span class="line"><span class="comment">	 * in the inverse case).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cse_is_idle &amp;&amp; !pse_is_idle)</span><br><span class="line">		<span class="keyword">goto</span> preempt;</span><br><span class="line">	<span class="keyword">if</span> (cse_is_idle != pse_is_idle)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	cfs_rq = cfs_rq_of(se);</span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * XXX pick_eevdf(cfs_rq) != se ?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pick_eevdf(cfs_rq) == pse)</span><br><span class="line">		<span class="keyword">goto</span> preempt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">preempt:</span><br><span class="line">	resched_curr(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到</p>
<ul>
<li>当 curr 运行的是 idle process 的时候，会 goto preempt 执行抢占（标记 TIF_NEED_RESCHED）</li>
<li>另外当 eevdf 相关的逻辑执行的时候，也会标记 TIF_NEED_RESCHED</li>
</ul>
<p>那什么时候执行抢占呢？这些 <a target="_blank" rel="noopener" href="https://hackmd.io/@sysprog/linux-preempt#%E4%BD%95%E6%99%82%E5%9F%B7%E8%A1%8C%E6%90%B6%E4%BD%94%EF%BC%9F">博客</a> 和 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45030965/article/details/128646726">博客</a> 讲的很好，简单说</p>
<ul>
<li>用户态抢占<ul>
<li>system call 结束，准备返回 user mode。 <code>do_syscall_64()</code> -&gt; <code>syscall_exit_to_user_mode()</code> -&gt; <code>exit_to_user_mode_prepare()</code> -&gt; <code>exit_to_user_mode_loop()</code></li>
<li>中断结束，准备返回 user mode<ul>
<li><code>irqentry_exit() </code> -&gt; <code>irqentry_exit_cond_resched()</code></li>
<li><code>prepare_exit_to_usermode()</code>-&gt;<code>prepare_exit_to_usermode()</code>-&gt;<code> exit_to_usermode_loop()</code></li>
</ul>
</li>
</ul>
</li>
<li>内核态抢占<ul>
<li>系统调用 <code>preempt_enable</code> 时</li>
<li>从中断返回内核态</li>
</ul>
</li>
</ul>
<h2 id="7-put-prev-task-set-next-task-pick-task"><a href="#7-put-prev-task-set-next-task-pick-task" class="headerlink" title="7 put_prev_task &amp; set_next_task &amp; pick_task()"></a>7 put_prev_task &amp; set_next_task &amp; pick_task()</h2><p>Called right before p is going to be taken off the CPU. 把 task 拿下 cpu。</p>
<p>有几种情形会用到他们 </p>
<ol>
<li>schedule() 进行 context switch 时</li>
<li>tasks migrate between between sched group&#x2F;classes</li>
</ol>
<p>这里我们看一下 schedule conext swtich 时的逻辑</p>
<p>在 <code>__schedule()</code> 中，挑选下一个 task 的时候调用到了 <code>next = pick_next_task(rq, prev, &amp;rf);</code> ，这其中主要做了两件事情。一个是把之前的 task 通过 <code>put_prev_task()</code> 从调度类里 <strong>拿下</strong> CPU，再挑选通过 <code>pick_next_task()</code>挑选合适的 task，然后把下一个挑选到的 task 通过 <code>set_next_task</code> <strong>放上</strong> CPU 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>, *<span class="title">p</span>, *<span class="title">max</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">smt_mask</span>;</span></span><br><span class="line">	<span class="type">bool</span> fi_before = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> core_clock_updated = (rq == rq-&gt;core);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cookie;</span><br><span class="line">	<span class="type">int</span> i, cpu, occ = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq_i</span>;</span></span><br><span class="line">	<span class="type">bool</span> need_sync;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果未启用 CONFIG_SCHED_CORE core aware scheduling。</span></span><br><span class="line">  <span class="comment">// 则调用__pick_next_task。</span></span><br><span class="line">	<span class="keyword">if</span> (!sched_core_enabled(rq))</span><br><span class="line">		<span class="keyword">return</span> __pick_next_task(rq, prev, rf);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后面都是 core scheduling 相关的内容，比较复杂，很多细节还不是很理解。</span></span><br><span class="line">	cpu = cpu_of(rq);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看下 <code>__pick_next_task</code>，比较清晰易懂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">pick_next_task</span>(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 CFS sched_class 是唯一一个有 running task 的，直接调用 cfs 相关的 pick_next_task 函数</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!sched_class_above(prev-&gt;sched_class, &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line"></span><br><span class="line">		p = pick_next_task_fair(rq, prev, rf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有选出来，那么就进入 idle</span></span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			put_prev_task(rq, prev);</span><br><span class="line">			p = pick_next_task_idle(rq);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">  <span class="comment">// 在核间做 balance 后，再做 put_prev_task</span></span><br><span class="line">	put_prev_task_balance(rq, prev, rf);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历每个 sched_class 执行 pick_next_task</span></span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BUG(); <span class="comment">/* The idle class should always have a runnable task. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Fast path<ul>
<li>如果 CFS sched_class 是唯一一个有 running task 的，直接调用 cfs 相关的 pick_next_task 接口实现方法</li>
<li>如果没有选出来，那么就进入 idle</li>
</ul>
</li>
<li>正常流程<ul>
<li>先调用 load balance 接口实现方法再执行 put_prev_task</li>
<li>然后遍历每个 sched_class 执行 pick_next_task</li>
</ul>
</li>
</ul>
<p>从代码来看，非 core scheduling 的时候，不需要调用 set_next_task。</p>
<h2 id="8-select-task-rq"><a href="#8-select-task-rq" class="headerlink" title="8. select_task_rq"></a>8. select_task_rq</h2><p>TBD</p>
<h2 id="9-migrate-task-rq-balance"><a href="#9-migrate-task-rq-balance" class="headerlink" title="9. migrate_task_rq &amp; balance"></a>9. migrate_task_rq &amp; balance</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_balance_newidle is called by schedule() if this_cpu is about to become</span></span><br><span class="line"><span class="comment"> * idle. Attempts to pull tasks from other CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *   &lt; 0 - we released the lock and there are !fair tasks present</span></span><br><span class="line"><span class="comment"> *     0 - failed, no new tasks</span></span><br><span class="line"><span class="comment"> *   &gt; 0 - success, new (fair) tasks present</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sched_balance_newidle</span><span class="params">(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> rq_flags *rf)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前进程即将变空的时候，尝试从其他 cpu rq 里拉取 task。</p>
<p>migrate_task_rq 表示当 task 从一个 CPU 迁移到了另一个 CPU 之后，发现准备迁移了，调用 migrate_task_rq 方法。</p>
<p>reference: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mysky007/p/12342599.html">schedule 函数的调用过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mysky007/p/12342505.html">抢占式调度</a></li>
<li><a target="_blank" rel="noopener" href="https://freegeektime.com/100024701/93711/">17 | 调度（下）：抢占式调度是如何发生的？</a></li>
<li><a target="_blank" rel="noopener" href="https://www3.cs.stonybrook.edu/~youngkwon/cse306/Lecture16_Linux_Process_Scheduling.pdf">CSE 306 Operating Systems Linux Process Scheduling</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-basic-concepts"><span class="toc-number">1.</span> <span class="toc-text">0. basic concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-schedule-%E8%B0%83%E5%BA%A6%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.</span> <span class="toc-text">1. schedule() 调度核心逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-enqueue-task-%E8%BF%9B%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">2.  enqueue_task - 进程加入运行队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-task-tick"><span class="toc-number">4.</span> <span class="toc-text">3. task_tick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-dequeue-task"><span class="toc-number">5.</span> <span class="toc-text">4. dequeue_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-yield-task"><span class="toc-number">6.</span> <span class="toc-text">5. yield_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-wakeup-preempt"><span class="toc-number">7.</span> <span class="toc-text">6. wakeup_preempt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-put-prev-task-set-next-task-pick-task"><span class="toc-number">8.</span> <span class="toc-text">7 put_prev_task &amp; set_next_task &amp; pick_task()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-select-task-rq"><span class="toc-number">9.</span> <span class="toc-text">8. select_task_rq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-migrate-task-rq-balance"><span class="toc-number">10.</span> <span class="toc-text">9. migrate_task_rq &amp; balance</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&text=about scheduler interface"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&is_video=false&description=about scheduler interface"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=about scheduler interface&body=Check out this article: https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&title=about scheduler interface"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&name=about scheduler interface&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://middaywords.github.io/2025/01/12/2025-0112-cfs-implementation/&t=about scheduler interface"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    Kangjie Xu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/middaywords">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
